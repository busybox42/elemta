input {
  beats {
    port => 5044
  }
  
  # Direct log file input for Elemta logs
  file {
    path => "/var/log/elemta/*.log"
    start_position => "beginning"
    tags => ["elemta-file"]
  }
}

filter {
  # Parse Elemta SMTP logs
  if [fields][service] == "elemta" or "elemta" in [tags] {
    
    # Parse standard Go log format with timestamp
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:log_message}" 
      }
      tag_on_failure => ["_grokparsefailure_timestamp"]
    }
    
    # Parse SMTP session logs
    if [log_message] =~ /SMTP:/ {
      grok {
        match => { 
          "log_message" => "SMTP: %{TIMESTAMP_ISO8601:smtp_timestamp} %{GREEDYDATA:smtp_message}" 
        }
        tag_on_failure => ["_grokparsefailure_smtp"]
      }
      
      # Parse SMTP connection events
      if [smtp_message] =~ /new connection/ {
        grok {
          match => { 
            "smtp_message" => "new connection: %{IPORHOST:client_ip}:%{INT:client_port}" 
          }
          add_field => { "event_type" => "smtp_connection" }
        }
      }
      
      # Parse SMTP commands
      else if [smtp_message] =~ /(EHLO|HELO|MAIL|RCPT|DATA|QUIT|AUTH)/ {
        grok {
          match => { 
            "smtp_message" => "(?<smtp_command>EHLO|HELO|MAIL|RCPT|DATA|QUIT|AUTH) %{GREEDYDATA:command_data}" 
          }
          add_field => { "event_type" => "smtp_command" }
        }
      }
    }
    
    # Parse queue processor logs
    else if [log_message] =~ /component=queue-processor/ {
      grok {
        match => { 
          "log_message" => ".*message_id=%{DATA:message_id}.*from=%{EMAILADDRESS:sender}.*to=\[%{EMAILADDRESS:recipient}\]" 
        }
        tag_on_failure => ["_grokparsefailure_queue"]
      }
      mutate {
        add_field => { "event_type" => "queue_processing" }
      }
    }
    
    # Parse delivery logs
    else if [log_message] =~ /component=lmtp-delivery/ {
      grok {
        match => { 
          "log_message" => ".*message_id=%{DATA:message_id}.*from=%{EMAILADDRESS:sender}.*to=\[%{EMAILADDRESS:recipient}\]" 
        }
        tag_on_failure => ["_grokparsefailure_delivery"]
      }
      mutate {
        add_field => { "event_type" => "message_delivery" }
      }
    }
    
    # Parse authentication logs
    else if [log_message] =~ /authentication/ {
      mutate {
        add_field => { "event_type" => "authentication" }
      }
    }
    
    # Parse error messages
    if [level] == "ERROR" {
      mutate {
        add_field => { "is_error" => "true" }
      }
    }
    
    # Convert timestamp
    if [timestamp] {
      date {
        match => [ "timestamp", "ISO8601" ]
        target => "@timestamp"
      }
    }
    
    # Add service identification
    mutate {
      add_field => { "service" => "elemta-smtp" }
      add_field => { "environment" => "docker" }
    }
    
    # Clean up fields
    mutate {
      remove_field => [ "agent", "ecs", "host", "input" ]
    }
  }
  
  # Parse Docker container logs
  if [container] {
    mutate {
      add_field => { "container_name" => "%{[container][name]}" }
      add_field => { "container_id" => "%{[container][id]}" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["elemta-elasticsearch:9200"]
    index => "elemta-logs-%{+YYYY.MM.dd}"
    template_name => "elemta-logs"
    template_pattern => "elemta-logs-*"
    template => {
      "index_patterns" => ["elemta-logs-*"]
      "settings" => {
        "number_of_shards" => 1
        "number_of_replicas" => 0
      }
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" }
          "level" => { "type" => "keyword" }
          "event_type" => { "type" => "keyword" }
          "service" => { "type" => "keyword" }
          "client_ip" => { "type" => "ip" }
          "sender" => { "type" => "keyword" }
          "recipient" => { "type" => "keyword" }
          "message_id" => { "type" => "keyword" }
          "smtp_command" => { "type" => "keyword" }
          "is_error" => { "type" => "boolean" }
          "container_name" => { "type" => "keyword" }
        }
      }
    }
  }
  
  # Debug output for development
  stdout { 
    codec => rubydebug 
  }
} 