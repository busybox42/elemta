input {
  beats {
    port => 5044
  }
  
  # Direct log file input for Elemta logs
  file {
    path => "/var/log/elemta/*.log"
    start_position => "beginning"
    tags => ["elemta-file"]
  }
}

filter {
  # Parse JSON logs first
  if [message] =~ /^\{/ {
    json {
      source => "message"
      skip_on_invalid_json => true
    }
  }

  # Skip debug and system logs that shouldn't be in MTA flows
  if [message] =~ /InitBuiltinPlugins/ or
     [message] =~ /Starting server/ or
     [message] =~ /Loaded plugin/ or
     [message] =~ /Plugin manager/ or
     [message] =~ /Configuration/ or
     [level] == "DEBUG" {
    drop { }
  }

  # Extract the actual log message from JSON or plain text
  if [msg] {
    mutate { add_field => { "log_message" => "%{msg}" } }
  } else if [message] and [message] !~ /^\{/ {
    mutate { add_field => { "log_message" => "%{message}" } }
  }

  # UNIVERSAL EMAIL METADATA EXTRACTION - Simplified patterns
  # Extract from= field (sender) - matches "from=email@domain.com"
  if [log_message] =~ /from=/ {
    ruby {
      code => '
        if event.get("log_message") =~ /from=([^@\s]+@[^@\s]+)/
          event.set("mail_from", $1)
        end
      '
    }
  }

  # Extract to= field (recipient) - matches "to=[email@domain.com]"
  if [log_message] =~ /to=/ {
    ruby {
      code => '
        if event.get("log_message") =~ /to=\[?([^@\s\]]+@[^@\s\]]+)\]?/
          event.set("mail_to", $1)
        end
      '
    }
  }

  # Extract message_id - matches "message_id=1234567890-1234567890"
  if [log_message] =~ /message_id=/ {
    ruby {
      code => '
        if event.get("log_message") =~ /message_id=([^\s]+)/
          event.set("message_id", $1)
        end
      '
    }
  }

  # Extract retry_count - matches "retry_count=0"
  if [log_message] =~ /retry_count=/ {
    ruby {
      code => '
        if event.get("log_message") =~ /retry_count=([0-9]+)/
          event.set("retry_count", $1.to_i)
        end
      '
    }
  }

  # Extract error messages - matches error="message"
  if [log_message] =~ /error=/ {
    ruby {
      code => '
        if event.get("log_message") =~ /error="([^"]+)"/
          event.set("error_reason", $1)
        end
      '
    }
  }

  # Extract server information - matches "server=hostname:port"
  if [log_message] =~ /server=/ {
    ruby {
      code => '
        if event.get("log_message") =~ /server=([^\s]+)/
          event.set("delivery_server", $1)
        end
      '
    }
  }

  # Extract client IP from remote_addr or message
  if [remote_addr] {
    ruby {
      code => '
        if event.get("remote_addr") =~ /([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+|[0-9a-fA-F:]+)/
          event.set("client_ip", $1)
        end
      '
    }
  }

  # Extract subject from JSON logs (enhanced logging)
  if [subject] and [subject] != "" {
    mutate {
      add_field => { "email_subject" => "%{subject}" }
    }
  }

  # Extract subject from email headers (if available in logs)
  if [log_message] =~ /[Ss]ubject:/ {
    ruby {
      code => '
        if event.get("log_message") =~ /[Ss]ubject:\s*([^\r\n]+)/
          event.set("subject", $1.strip)
        end
      '
    }
  }

  # Extract subject from email headers field
  if [email_headers] and [email_headers] != "" {
    ruby {
      code => '
        headers = event.get("email_headers")
        if headers =~ /Subject:\s*([^\r\n\\\\]+)/i
          event.set("subject", $1.strip)
        end
      '
    }
  }

  # Extract email content when logged (if available)
  if [log_message] =~ /content:/ {
    ruby {
      code => '
        if event.get("log_message") =~ /content:\s*(.+)/
          event.set("email_content", $1)
        end
      '
    }
  }

  # Extract email headers when available from JSON logs
  if [headers] {
    mutate {
      add_field => { "email_headers" => "%{headers}" }
    }
  }

  # Extract email headers from legacy log format
  if [log_message] =~ /headers:/ {
    ruby {
      code => '
        if event.get("log_message") =~ /headers:\s*(.+)/
          event.set("email_headers", $1)
        end
      '
    }
  }

  # RECEPTION FLOW - New sessions, connections, message acceptance
  if [log_message] =~ /starting new session/ or
     [log_message] =~ /message accepted/ or 
     [log_message] =~ /message queued successfully/ or
     [log_message] =~ /queued as/ or
     [log_message] =~ /Message queued/ or
     [component] == "smtp-session" and [msg] =~ /(accepted|queued)/ {
    
    mutate { add_field => { "mta_flow" => "reception" } }
  }

  # DELIVERY FLOW - Successful deliveries, LMTP attempts
  else if [log_message] =~ /delivered to/ or
          [log_message] =~ /delivery successful/ or
          [log_message] =~ /Attempting LMTP delivery/ or
          [log_message] =~ /status=sent/ or
          [component] == "lmtp-delivery" {
    
    mutate { add_field => { "mta_flow" => "delivery" } }
  }

  # REJECTION FLOW - Rejections, spam, blocks
  else if [log_message] =~ /rejected/ or
          [log_message] =~ /blocked/ or
          [log_message] =~ /denied/ or
          [log_message] =~ /spam/ or
          [log_message] =~ /blacklist/ or
          [log_message] =~ /policy.*reject/ {
    
         # Extract rejection reason
     if [log_message] =~ /reason[:=]/ {
       grok {
         match => { "log_message" => "reason[:=]\\s*\"?(?<rejection_reason>[^\"\\n]+)\"?" }
         tag_on_failure => []
       }
     }
    
    mutate { add_field => { "mta_flow" => "rejection" } }
  }

  # TEMPFAIL FLOW - Temporary failures, deferred, retries
  else if [log_message] =~ /tempfail/ or
          [log_message] =~ /deferred/ or
          [log_message] =~ /moved to deferred/ or
          [log_message] =~ /delivery failed/ or
          [log_message] =~ /Message moved to deferred/ or
          [log_message] =~ /status=deferred/ {
    
    mutate { add_field => { "mta_flow" => "tempfail" } }
  }

  # BOUNCE FLOW - Permanent failures, bounces
  else if [log_message] =~ /bounce/ or
          [log_message] =~ /permanent.*failure/ or
          [log_message] =~ /status=bounced/ or
          [log_message] =~ /undeliverable/ or
          [log_message] =~ /moved to failed/ {
    
         # Extract bounce reason
     if [log_message] =~ /reason[:=]/ {
       grok {
         match => { "log_message" => "reason[:=]\\s*\"?(?<bounce_reason>[^\"\\n]+)\"?" }
         tag_on_failure => []
       }
     }
    
    mutate { add_field => { "mta_flow" => "bounce" } }
  }

  # SYSTEM FLOW - Server operations, connections, non-email events
  else if [component] == "smtp-session" or
          [log_message] =~ /session/ or
          [log_message] =~ /connection/ or
          [log_message] =~ /server/ {
    mutate { add_field => { "mta_flow" => "system" } }
  }

  # Add timestamp parsing
  if [time] {
    date {
      match => [ "time", "ISO8601" ]
    }
  }

  # Clean up fields and add useful metadata
  mutate {
    remove_field => [ "agent", "ecs", "input", "log" ]
  }
  
  # Ensure we have a flow classification
  if ![mta_flow] {
    mutate { add_field => { "mta_flow" => "unclassified" } }
  }

  # Ensure essential fields are always present (even if empty)
  if ![mail_from] {
    mutate { add_field => { "mail_from" => "" } }
  }
  if ![mail_to] {
    mutate { add_field => { "mail_to" => "" } }
  }
  if ![client_ip] {
    mutate { add_field => { "client_ip" => "" } }
  }
  if ![subject] {
    mutate { add_field => { "subject" => "" } }
  }
  if ![message_id] {
    mutate { add_field => { "message_id" => "" } }
  }
  if ![email_content] {
    mutate { add_field => { "email_content" => "" } }
  }
  if ![email_headers] {
    mutate { add_field => { "email_headers" => "" } }
  }
}

output {
  # Route to different indices based on MTA flow
  if [mta_flow] == "reception" {
    elasticsearch {
      hosts => ["elemta-elasticsearch:9200"]
      index => "elemta-reception-%{+YYYY.MM.dd}"
    }
  } else if [mta_flow] == "delivery" {
    elasticsearch {
      hosts => ["elemta-elasticsearch:9200"]
      index => "elemta-delivery-%{+YYYY.MM.dd}"
    }
  } else if [mta_flow] == "rejection" {
    elasticsearch {
      hosts => ["elemta-elasticsearch:9200"]
      index => "elemta-rejection-%{+YYYY.MM.dd}"
    }
  } else if [mta_flow] == "tempfail" {
    elasticsearch {
      hosts => ["elemta-elasticsearch:9200"]
      index => "elemta-tempfail-%{+YYYY.MM.dd}"
    }
  } else if [mta_flow] == "bounce" {
    elasticsearch {
      hosts => ["elemta-elasticsearch:9200"]
      index => "elemta-bounce-%{+YYYY.MM.dd}"
    }
  } else if [mta_flow] == "system" {
    elasticsearch {
      hosts => ["elemta-elasticsearch:9200"]
      index => "elemta-system-%{+YYYY.MM.dd}"
    }
  } else {
    # Fallback for unclassified logs
    elasticsearch {
      hosts => ["elemta-elasticsearch:9200"]
      index => "elemta-unclassified-%{+YYYY.MM.dd}"
    }
  }

  # Debug output disabled for production
} 