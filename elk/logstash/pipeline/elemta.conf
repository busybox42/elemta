input {
  beats {
    port => 5044
  }
  
  # Direct log file input for Elemta logs
  file {
    path => "/var/log/elemta/*.log"
    start_position => "beginning"
    tags => ["elemta-file"]
  }
}

filter {
  # Extract container metadata first
  if [container] {
    mutate {
      add_field => { "container_name" => "%{[container][name]}" }
      add_field => { "container_id" => "%{[container][id]}" }
    }
  }
  
  # Debug: Add a tag to all messages for troubleshooting
  mutate {
    add_tag => [ "logstash_processed" ]
  }
  
  # Only process elemta-node0 container logs - check both possible fields
  if [container_name] == "elemta-node0" or [container][name] == "elemta-node0" {
    
    # Add debug tag for container match
    mutate {
      add_tag => [ "elemta_container_matched" ]
    }
    
    # Handle JSON structured logs (most common in elemta-node0)
    if [message] =~ /^\{.*\}$/ {
      mutate {
        add_tag => [ "json_pattern_matched" ]
      }
      
      json {
        source => "message"
      }
      
      # Extract JSON fields to top level for better indexing
      if [time] {
        mutate {
          rename => { "time" => "log_timestamp" }
          rename => { "level" => "log_level" }
          rename => { "msg" => "log_message" }
          rename => { "component" => "log_component" }
          add_field => { "log_format" => "json" }
          add_tag => [ "json_parsed_successfully" ]
        }
        
        # Parse the timestamp
        date {
          match => [ "log_timestamp", "ISO8601" ]
          target => "@timestamp"
        }
        
        # Extract session details
        if [session_id] {
          mutate {
            add_field => { "event_type" => "smtp_session" }
          }
        }
        
        # Parse remote address to extract client IP and port
        if [remote_addr] {
          grok {
            match => { "remote_addr" => "(?:\[)?(?<client_ip>[^\]:]+)(?:\])?:(?<client_port>\d+)" }
            tag_on_failure => ["_grokparsefailure_remote_addr"]
          }
        }
        
        # Mark errors
        if [log_level] == "ERROR" {
          mutate {
            add_field => { "is_error" => true }
          }
        }
      }
    }
    
    # Handle SMTP connection logs
    else if [message] =~ /^SMTP:/ {
      mutate {
        add_tag => [ "smtp_pattern_matched" ]
      }
      
      grok {
        match => { 
          "message" => "SMTP: %{TIMESTAMP_ISO8601:log_timestamp} %{GREEDYDATA:log_message}" 
        }
      }
      
      mutate {
        add_field => { "log_format" => "smtp" }
        add_field => { "log_level" => "INFO" }
        add_field => { "log_component" => "smtp-connection" }
      }
      
      # Extract connection details
      if [log_message] =~ /new connection/ {
        grok {
          match => { 
            "log_message" => "new connection: (?:\[)?(?<client_ip>[^\]:]+)(?:\])?:(?<client_port>\d+)" 
          }
        }
        mutate {
          add_field => { "event_type" => "connection_new" }
        }
      }
      
      # Parse timestamp
      if [log_timestamp] {
        date {
          match => [ "log_timestamp", "ISO8601" ]
          target => "@timestamp"
        }
      }
    }
    
    # Handle standard Go logs (queue processing, delivery, etc.)
    else if [message] =~ /^\d{4}\/\d{2}\/\d{2}/ {
      mutate {
        add_tag => [ "go_log_pattern_matched" ]
      }
      
      grok {
        match => { 
          "message" => "%{TIMESTAMP_ISO8601:log_timestamp} %{LOGLEVEL:log_level} %{GREEDYDATA:log_message}" 
        }
      }
      
      mutate {
        add_field => { "log_format" => "go_standard" }
      }
      
      # Extract component from log message
      if [log_message] =~ /component=([^\s]+)/ {
        grok {
          match => { "log_message" => ".*component=(?<log_component>[^\s]+)" }
        }
      }
      
      # Parse queue processor logs
      if [log_component] == "queue-processor" {
        mutate {
          add_field => { "event_type" => "queue_processing" }
        }
        
        # Extract message details
        if [log_message] =~ /message_id=/ {
          grok {
            match => { 
              "log_message" => ".*message_id=(?<message_id>[^\s]+).*from=(?<sender>[^\s]+).*to=\[(?<recipient>[^\]]+)\]" 
            }
            tag_on_failure => ["_grokparsefailure_queue_details"]
          }
        }
        
        # Extract retry count
        if [log_message] =~ /retry_count=/ {
          grok {
            match => { "log_message" => ".*retry_count=(?<retry_count>\d+)" }
          }
        }
        
        # Extract count for queue operations
        if [log_message] =~ /count=/ {
          grok {
            match => { "log_message" => ".*count=(?<queue_count>\d+)" }
          }
        }
      }
      
      # Parse LMTP delivery logs
      else if [log_component] == "lmtp-delivery" {
        mutate {
          add_field => { "event_type" => "message_delivery" }
        }
        
        # Extract delivery details
        grok {
          match => { 
            "log_message" => ".*message_id=(?<message_id>[^\s]+).*from=(?<sender>[^\s]+).*to=\[(?<recipient>[^\]]+)\].*server=(?<delivery_server>[^\s]+)" 
          }
          tag_on_failure => ["_grokparsefailure_delivery_details"]
        }
        
        # Extract LMTP response
        if [log_message] =~ /response=/ {
          grok {
            match => { "log_message" => ".*response=\"(?<lmtp_response>[^\"]+)\"" }
          }
        }
      }
      
      # Mark errors
      if [log_level] == "ERROR" {
        mutate {
          add_field => { "is_error" => true }
        }
      }
      
      # Parse timestamp
      if [log_timestamp] {
        date {
          match => [ "log_timestamp", "ISO8601" ]
          target => "@timestamp"
        }
      }
    }
    
    # Add common fields for all elemta-node0 logs
    mutate {
      add_field => { "service_name" => "elemta-smtp" }
      add_field => { "environment" => "docker" }
    }
    
    # Convert numeric fields
    if [client_port] {
      mutate {
        convert => { "client_port" => "integer" }
      }
    }
    
    if [retry_count] {
      mutate {
        convert => { "retry_count" => "integer" }
      }
    }
    
    if [queue_count] {
      mutate {
        convert => { "queue_count" => "integer" }
      }
    }
    
    # Clean up unnecessary fields
    mutate {
      remove_field => [ "agent", "ecs", "host", "input", "stream", "log" ]
    }
  }
}

output {
  elasticsearch {
    hosts => ["elemta-elasticsearch:9200"]
    index => "elemta-logs-%{+YYYY.MM.dd}"
    ilm_enabled => false
  }
} 