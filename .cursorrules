# Elemta Project - Cursor AI Rules

## Project Overview
This is Elemta, a high-performance SMTP server written in Go. Always consult the documentation in `.notes/` before starting work.

## Required Reading Before Starting
- **ALWAYS** read `.notes/project_overview.md` for project context
- **ALWAYS** check `.notes/task_list.md` for current priorities and task status
- **ALWAYS** review `.notes/decision_log.md` for architectural decisions
- Check `.notes/directory_structure.md` to understand file organization

## Critical Project Issues (P0 Priority)
1. **Missing Main Entry Point**: `cmd/elemta/main.go` doesn't exist - this blocks all development
2. **Configuration Chaos**: Multiple config formats (YAML/TOML/JSON) need standardization
3. **Mock Authentication**: Production code uses mock datasources - security risk

## Development Standards

### Go Code Style
- Follow `gofmt` and `goimports` formatting
- Use `golangci-lint` for code quality
- Error handling: Always use `fmt.Errorf("operation failed: %w", err)` for wrapping
- Context: Pass `context.Context` as first parameter for all operations
- Logging: Use structured logging with `slog` package

### File Structure Rules
- Core implementation in `internal/` 
- Entry points in `cmd/`
- Configuration in `config/`
- Documentation in `docs/` and `.notes/`
- Tests alongside implementation files

### Testing Requirements
- Write table-driven tests for all new functionality
- Maintain 80%+ test coverage for critical paths
- Mock external dependencies
- Include integration tests for complex workflows

## Task Management Rules
1. **Before starting any task**: Update `.notes/task_list.md` status to üîÑ In Progress
2. **After completing a task**: Update status to ‚úÖ Completed with completion date
3. **If blocked**: Update status to üö´ Blocked with reason
4. **For decisions**: Log in `.notes/decision_log.md` with rationale

## Configuration Standards
- **Target Format**: TOML (decision pending in `.notes/decision_log.md`)
- **Validation**: All configs must have validation with clear error messages
- **Examples**: Provide working examples for all configuration options
- **Documentation**: Update docs when config changes

## Architecture Patterns

### Module Structure
Each module should follow this pattern:
```
internal/module/
‚îú‚îÄ‚îÄ module.go      # Main implementation
‚îú‚îÄ‚îÄ types.go       # Type definitions
‚îú‚îÄ‚îÄ config.go      # Configuration
‚îî‚îÄ‚îÄ module_test.go # Tests
```

### Interface Design
- Keep interfaces small and focused
- Define interfaces where they're used, not where they're implemented
- Use composition over inheritance

### Error Handling
- Return errors, don't panic
- Wrap errors with context: `fmt.Errorf("failed to process message: %w", err)`
- Log errors at appropriate levels
- Provide actionable error messages

## Security Requirements
- **Authentication**: Never use mock datasources in production code paths
- **TLS**: Always validate certificates in production
- **Input Validation**: Validate all external inputs
- **Logging**: Don't log sensitive information (passwords, keys)

## Performance Guidelines
- Use goroutines for concurrent operations
- Implement proper connection pooling
- Stream large messages, don't load entirely into memory
- Include context for cancellation and timeouts

## Docker and Deployment
- Always test changes in Docker environment first
- Update Docker configurations when changing build process
- Verify Kubernetes deployments work
- Test all docker-compose services start correctly

## Documentation Rules
- Update `.notes/` documentation when making architectural changes
- Keep README.md aligned with actual functionality
- Document all public APIs
- Include examples for complex operations

## Git Workflow
- Create feature branches for major changes
- Write descriptive commit messages
- Include issue references where applicable
- Update documentation in same commit as code changes

## Build and Testing Commands
```bash
# Standard build
make build

# Run all tests
go test -v ./...

# Docker environment
docker-compose up -d

# Format code
gofmt -w .
goimports -w .

# Lint code
golangci-lint run
```

## Priority Order for Development
1. **P0 (Critical)**: Fix main entry point, config standardization, remove mocks
2. **P1 (High)**: Build system, configuration validation, error handling
3. **P2 (Medium)**: Plugin hardening, documentation, testing
4. **P3 (Low)**: Performance optimization, enterprise features

## Common File Locations
- Main server: `cmd/elemta/main.go` (‚ùå MISSING - CREATE THIS FIRST)
- SMTP server: `internal/smtp/server.go`
- Queue system: `internal/queue/manager.go`
- Plugin system: `internal/plugin/manager.go`
- Configuration: `internal/config/config.go`
- Build config: `Makefile`, `Dockerfile`

## Module-Specific Guidelines

### SMTP Module (`internal/smtp/`)
- See `.notes/smtp_module.md` for detailed documentation
- Focus on protocol compliance and performance
- Implement proper session handling

### Queue Module (`internal/queue/`)
- See `.notes/queue_module.md` for detailed documentation
- Ensure message persistence and recovery
- Implement robust retry logic

### Plugin Module (`internal/plugin/`)
- See `.notes/plugin_module.md` for detailed documentation
- Plugin failures must not crash server
- Implement proper plugin isolation

## Emergency Contacts
- Check `.notes/milestones.md` for timeline and deadlines
- Review `.notes/decision_log.md` for pending decisions
- Escalate architectural decisions to project lead

## Remember
- **Quality over speed**: This is production email infrastructure
- **Security first**: Email servers are high-value attack targets  
- **Test everything**: Email reliability is critical
- **Document decisions**: Future developers need context 